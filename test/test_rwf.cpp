#include <stdio.h>
#include <string.h>
#include <raimd/md_msg.h>
#include <raimd/md_dict.h>
#include <raimd/app_a.h>
#include <raimd/enum_def.h>
#include <raimd/rwf_msg.h>

using namespace rai;
using namespace md;

static int
get_arg( const char *arg,  int argc,  char **argv ) noexcept
{
  for ( int i = 1; i < argc; i++ )
    if ( ::strcmp( argv[ i ], arg ) == 0 )
      return i;
  return -1;
}

static void test_pre_made( MDDict *dict ) noexcept;

int
main( int argc, char **argv )
{
  MDDictBuild dict_build;
  MDDict * dict = NULL;
  const char * path = ::getenv( "cfile_path" );
  int path_arg = get_arg( "-p", argc, argv );

  if ( argc > 1 && ::strcmp( argv[ 1 ], "-h" ) == 0 ) {
    fprintf( stderr,
      "Test unpacking md msg basic types\n" );
    return 1;
  }

  if ( path_arg > 0 && path_arg + 1 < argc )
    path = argv[ path_arg + 1 ];
  /* load RDM dictionary */
  if ( AppA::parse_path( dict_build, path, "RDMFieldDictionary" ) == 0 ) {
    EnumDef::parse_path( dict_build, path, "enumtype.def" );
    dict_build.index_dict( "app_a", dict );
  }

  if ( get_arg( "-t", argc, argv ) > 0 )
    test_pre_made( dict );

  MDOutput mout;
  MDMsgMem mem;
  MDMsg  * m;

  char buf[ 32 ];
  RwfFieldListWriter fl( mem, dict, buf, sizeof( buf ) );
  size_t sz;

  static char msg_type[] = "MSG_TYPE", rec_type[]   = "REC_TYPE",
              seq_no[]   = "SEQ_NO",   rec_status[] = "REC_STATUS";
  fl.append_int( msg_type, sizeof( msg_type ),  (short) 1 )
    .append_int( rec_type, sizeof( rec_type ),  (short) 0 )
    .append_int( seq_no, sizeof( seq_no ),  (short) 100 )
    .append_int( rec_status, sizeof( rec_status ), (short) 0 )
    .end_field_list();

  printf( "-- FieldList Msg test:\n" );
  mout.print_hex( fl.buf, fl.off );

  m = MDMsg::unpack( fl.buf, 0, fl.off, RWF_FIELD_LIST_TYPE_ID, dict, mem );
  if ( m != NULL )
    m->print( &mout );
  mem.reuse();

  uint32_t stream_id = 1;
  RwfMsgWriter msg( mem, dict, buf, sizeof( buf ),
                   REQUEST_MSG_CLASS, LOGIN_DOMAIN, stream_id );

  msg.set( X_STREAMING, X_MSG_KEY_IN_UPDATES )
     .add_qos( QOS_TIME_REALTIME, QOS_RATE_TICK_BY_TICK, false )
     .add_msg_key()
       .name( "chris" )
       .name_type( 1 )
       .attrib()
         .append_string( "ApplicationId"               , "256" )
         .append_string( "ApplicationName"             , "MyTest" )
         .append_string( "Password"                    , "secret" )
         .append_uint(   "ProvidePermissionProfile"    , 1 )
         .append_uint(   "ProvidePermissionExpressions", 1 )
         .append_uint(   "SingleOpen"                  , 1 )
         .append_uint(   "AllowSuspectData"            , 1 )
         .append_string( "InstanceId"                  , "instance1" )
         .append_uint(   "Role"                        , 0 )
         .append_uint(   "DownloadConnectionConfig"    , 0 )
     .end_msg_key();

  msg.add_field_list()
       .append_int( msg_type, (short) 1 )
       .append_int( rec_type, (short) 0 )
     .end();

  printf( "-- Msg test:\n" );
  mout.print_hex( msg.buf, msg.off );

  m = MDMsg::unpack( msg.buf, 0, msg.off, RWF_MSG_TYPE_ID, dict, mem );
  if ( m != NULL )
    m->print( &mout );
  mem.reuse();

  RwfMsgWriter upd( mem, dict, buf, sizeof( buf ),
                    UPDATE_MSG_CLASS, MARKET_BY_PRICE_DOMAIN, stream_id );
  MDReference mref;

  upd.set( X_DO_NOT_CACHE )
     .add_update( UPD_TYPE_QUOTE )
     .add_seq_num( 100 )
     .add_post_user( ( 127 << 24 ) | 1, 1 )
     .add_msg_key()
       .name( "INTC.O" )
       .name_type( 1 )
     .end_msg_key();

  RwfMapWriter &map = upd.add_map( MD_UINT );
  map.add_summary_element_list()
       .append_string( "SYMBOL", "INTC" )
       .append_real( "ASK", 1.0 )
       .append_real( "BID", 2.0 )
     .end_summary();

  map.add_element_list( MAP_ADD_ENTRY, 1, MD_UINT )
       .append_real( "ASK", 1.0 )
     .end_entry();

  map.add_element_list( MAP_UPDATE_ENTRY, 2, MD_UINT )
       .append_real( "ASK", 2.0 )
     .end_entry();
  upd.end();

  printf( "-- Upd test:\n" );
  mout.print_hex( upd.buf, upd.off );

  m = MDMsg::unpack( upd.buf, 0, upd.off, RWF_MSG_TYPE_ID, dict, mem );
  if ( m != NULL )
    m->print( &mout );
  mem.reuse();

  RwfMsgWriter cls( mem, dict, buf, sizeof( buf ),
                    CLOSE_MSG_CLASS, MARKET_PRICE_DOMAIN, stream_id );
  sz = cls.end();

  printf( "-- Close test:\n" );
  mout.print_hex( cls.buf, sz );

  m = MDMsg::unpack( cls.buf, 0, sz, RWF_MSG_TYPE_ID, dict, mem );
  if ( m != NULL )
    m->print( &mout );
  mem.reuse();

  RwfMsgWriter gen( mem, dict, buf, sizeof( buf ), GENERIC_MSG_CLASS,
                    SOURCE_DOMAIN, stream_id );
  RwfFilterListWriter & fi = gen.add_filter_list();

  fi.add_element_list( FILTER_UPDATE_ENTRY, 1 )
      .append_string( "test", "filters" )
      .append_string( "are", "wet" )
    .end_entry();
  fi.add_element_list( FILTER_SET_ENTRY, 2 )
      .append_string( "samu", "saba" )
      .append_uint( "okok", 4 )
    .end_entry();
  fi.add_field_list( FILTER_SET_ENTRY, 3 )
      .append_int( msg_type, sizeof( msg_type ), (short) 1 )
      .append_int( rec_type, sizeof( rec_type ), (short) 0 )
    .end_entry();

  RwfSeriesWriter &se = fi.add_series( FILTER_SET_ENTRY, 4 );
    se.add_summary_element_list()
      .append_uint( "sum1", 1 )
      .append_uint( "sum2", 2 )
      .append_uint( "sum3", 3 )
    .end_summary();
    se.add_element_list()
      .append_string( "x", "one" )
      .append_string( "y", "two" )
    .end_entry();
    se.add_element_list()
      .append_string( "a", "three" )
      .append_string( "b", "four" )
    .end_entry();
  gen.end();

  printf( "-- Generic test:\n" );
  mout.print_hex( gen.buf, gen.off );

  m = MDMsg::unpack( gen.buf, 0, gen.off, RWF_MSG_TYPE_ID, dict, mem );
  if ( m != NULL )
    m->print( &mout );
  mem.reuse();

  RwfVectorWriter vec( mem, dict, buf, sizeof( buf ) );
  vec.add_field_list( VECTOR_UPDATE_ENTRY, 1 )
     .append_int( msg_type, sizeof( msg_type ), (short) 1 )
     .append_int( rec_type, sizeof( rec_type ), (short) 0 )
     .append_int( seq_no, sizeof( seq_no ),  (short) 100 )
     .append_int( rec_status, sizeof( rec_status ), (short) 0 )
     .end_entry();
  vec.add_field_list( VECTOR_SET_ENTRY, 2 )
     .append_int( msg_type, sizeof( msg_type ), (short) 1 )
     .append_int( rec_type, sizeof( rec_type ), (short) 0 )
     .append_int( seq_no, sizeof( seq_no ),  (short) 101 )
     .append_int( rec_status, sizeof( rec_status ), (short) 1 )
     .end_entry();
  vec.end();

  printf( "-- Vector test:\n" );
  mout.print_hex( vec.buf, vec.off );

  m = MDMsg::unpack( vec.buf, 0, vec.off, RWF_VECTOR_TYPE_ID, dict, mem );
  if ( m != NULL )
    m->print( &mout );
  mem.reuse();

  return 0;
}

static void
test_pre_made( MDDict *dict ) noexcept
{
  MDOutput mout;
  MDMsgMem mem;
  MDMsg  * m;

  static uint8_t field_list[] = {
0x09,0x03,0x02,0x00,0x05,0x00,0x10,0x00,0x10,0x04,0x1e,0x0b,0x07,0xda,0x04,0x38,
0x02,0x5b,0xa0,0x04,0x39,0x02,0x5b,0xa0,0x00,0x16,0x00,0x00,0x18,0x03,0x0c,0x00,
0xe3,0x00,0x19,0x03,0x0a,0x59,0x11,0x00,0x12,0x03,0x08,0x27,0x18,0xff,0xff,0x03,
0x00,0xff,0x98,0xff,0xfe,0x04,0x40,0x48,0xf5,0xc3,0xff,0xfd,0x08,0x40,0x09,0x21,
0xff,0x2e,0x48,0xe8,0xa7,0xff,0xfc,0x07,0x0f,0x0b,0x07,0xdb,0x08,0x27,0x18,0xff,
0xfb,0x01,0x23,0xff,0xfa,0x0d,0x09,0x00,0x0a,0x53,0x75,0x63,0x63,0x65,0x65,0x64,
0x65,0x64,0x00,0xff,0xf9,0x0e,0x42,0x55,0x46,0x46,0x45,0x52,0x45,0x58,0x41,0x4d,
0x50,0x4c,0x45,0x00,0xff,0xf8,0x02,0x03,0xe7,0x03,0xfd,0xfe,0x00,0x0e,0x04,0x02,
0x00,0x05,0x00,0x0a,0x00,0x14,0x00,0x1e,0x00,0x28,0x5b,0xa0,
  };
  printf( "--- field\n" );
  m = MDMsg::unpack( field_list, 0, sizeof( field_list ),
                     RWF_FIELD_LIST_TYPE_ID, dict, mem );
  m->print( &mout );
  mem.reuse();

  static uint8_t map[] = {
0x0a,0x04,0x04,0x80,0x8c,0x09,0x03,0x02,0x00,0x05,0x00,0x10,0x00,0x10,0x04,0x1e,
0x0b,0x07,0xda,0x04,0x38,0x02,0x5b,0xa0,0x04,0x39,0x02,0x5b,0xa0,0x00,0x16,0x00,
0x00,0x18,0x03,0x0c,0x00,0xe3,0x00,0x19,0x03,0x0a,0x59,0x11,0x00,0x12,0x03,0x08,
0x27,0x18,0xff,0xff,0x03,0x00,0xff,0x98,0xff,0xfe,0x04,0x40,0x48,0xf5,0xc3,0xff,
0xfd,0x08,0x40,0x09,0x21,0xff,0x2e,0x48,0xe8,0xa7,0xff,0xfc,0x07,0x0f,0x0b,0x07,
0xdb,0x08,0x27,0x18,0xff,0xfb,0x01,0x23,0xff,0xfa,0x0d,0x09,0x00,0x0a,0x53,0x75,
0x63,0x63,0x65,0x65,0x64,0x65,0x64,0x00,0xff,0xf9,0x0e,0x42,0x55,0x46,0x46,0x45,
0x52,0x45,0x58,0x41,0x4d,0x50,0x4c,0x45,0x00,0xff,0xf8,0x02,0x03,0xe7,0x03,0xfd,
0xfe,0x00,0x0e,0x04,0x02,0x00,0x05,0x00,0x0a,0x00,0x14,0x00,0x1e,0x00,0x28,0x5b,
0xa0,0x03,0x00,0x03,0x01,0x01,0x01,0xfe,0x00,0x8c,0x09,0x03,0x02,0x00,0x05,0x00,
0x10,0x00,0x10,0x04,0x1e,0x0b,0x07,0xda,0x04,0x38,0x02,0x5b,0xa0,0x04,0x39,0x02,
0x5b,0xa0,0x00,0x16,0x00,0x00,0x18,0x03,0x0c,0x00,0xe3,0x00,0x19,0x03,0x0a,0x59,
0x11,0x00,0x12,0x03,0x08,0x27,0x18,0xff,0xff,0x03,0x00,0xff,0x98,0xff,0xfe,0x04,
0x40,0x48,0xf5,0xc3,0xff,0xfd,0x08,0x40,0x09,0x21,0xff,0x2e,0x48,0xe8,0xa7,0xff,
0xfc,0x07,0x0f,0x0b,0x07,0xdb,0x08,0x27,0x18,0xff,0xfb,0x01,0x23,0xff,0xfa,0x0d,
0x09,0x00,0x0a,0x53,0x75,0x63,0x63,0x65,0x65,0x64,0x65,0x64,0x00,0xff,0xf9,0x0e,
0x42,0x55,0x46,0x46,0x45,0x52,0x45,0x58,0x41,0x4d,0x50,0x4c,0x45,0x00,0xff,0xf8,
0x02,0x03,0xe7,0x03,0xfd,0xfe,0x00,0x0e,0x04,0x02,0x00,0x05,0x00,0x0a,0x00,0x14,
0x00,0x1e,0x00,0x28,0x5b,0xa0,0x02,0x01,0x02,0x8c,0x09,0x03,0x02,0x00,0x05,0x00,
0x10,0x00,0x10,0x04,0x1e,0x0b,0x07,0xda,0x04,0x38,0x02,0x5b,0xa0,0x04,0x39,0x02,
0x5b,0xa0,0x00,0x16,0x00,0x00,0x18,0x03,0x0c,0x00,0xe3,0x00,0x19,0x03,0x0a,0x59,
0x11,0x00,0x12,0x03,0x08,0x27,0x18,0xff,0xff,0x03,0x00,0xff,0x98,0xff,0xfe,0x04,
0x40,0x48,0xf5,0xc3,0xff,0xfd,0x08,0x40,0x09,0x21,0xff,0x2e,0x48,0xe8,0xa7,0xff,
0xfc,0x07,0x0f,0x0b,0x07,0xdb,0x08,0x27,0x18,0xff,0xfb,0x01,0x23,0xff,0xfa,0x0d,
0x09,0x00,0x0a,0x53,0x75,0x63,0x63,0x65,0x65,0x64,0x65,0x64,0x00,0xff,0xf9,0x0e,
0x42,0x55,0x46,0x46,0x45,0x52,0x45,0x58,0x41,0x4d,0x50,0x4c,0x45,0x00,0xff,0xf8,
0x02,0x03,0xe7,0x03,0xfd,0xfe,0x00,0x0e,0x04,0x02,0x00,0x05,0x00,0x0a,0x00,0x14,
0x00,0x1e,0x00,0x28,0x5b,0xa0,0x03,0x01,0x03
  };
  printf( "--- map\n" );
  m = MDMsg::unpack( map, 0, sizeof( map ), RWF_MAP_TYPE_ID, dict, mem );
  m->print( &mout );
  mem.reuse();

  static uint8_t elem[] = {
0x09,0x02,0x00,0x05,0x00,0x04,0x12,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,
0x20,0x52,0x73,0x73,0x6c,0x54,0x69,0x6d,0x65,0x0a,0x05,0x0a,0x15,0x10,0x03,0x09,
0x11,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x49,
0x6e,0x74,0x03,0x01,0x0d,0x12,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,
0x52,0x73,0x73,0x6c,0x55,0x49,0x6e,0x74,0x04,0x01,0x11,0x1a,0x45,0x6c,0x65,0x6d,
0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x52,0x65,0x61,0x6c,0x20,0x2d,
0x20,0x42,0x6c,0x61,0x6e,0x6b,0x08,0x00
  };
  printf( "--- element\n" );
  m = MDMsg::unpack( elem, 0, sizeof( elem ), RWF_ELEMENT_LIST_TYPE_ID,
                     dict, mem );
  m->print( &mout );
  mem.reuse();

  static uint8_t filt[] = {
0x00,0x05,0x03,0x01,0x01,0x68,0x09,0x02,0x00,0x05,0x00,0x04,0x12,0x45,0x6c,0x65,
0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x54,0x69,0x6d,0x65,0x0a,
0x05,0x0a,0x15,0x10,0x03,0x09,0x11,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,
0x20,0x52,0x73,0x73,0x6c,0x49,0x6e,0x74,0x03,0x01,0x0d,0x12,0x45,0x6c,0x65,0x6d,
0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x55,0x49,0x6e,0x74,0x04,0x01,
0x11,0x1a,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,
0x52,0x65,0x61,0x6c,0x20,0x2d,0x20,0x42,0x6c,0x61,0x6e,0x6b,0x08,0x00,0x21,0x02,
0x04,0x8c,0x09,0x03,0x02,0x00,0x05,0x00,0x10,0x00,0x10,0x04,0x1e,0x0b,0x07,0xda,
0x04,0x38,0x02,0x5b,0xa0,0x04,0x39,0x02,0x5b,0xa0,0x00,0x16,0x00,0x00,0x18,0x03,
0x0c,0x00,0xe3,0x00,0x19,0x03,0x0a,0x59,0x11,0x00,0x12,0x03,0x08,0x27,0x18,0xff,
0xff,0x03,0x00,0xff,0x98,0xff,0xfe,0x04,0x40,0x48,0xf5,0xc3,0xff,0xfd,0x08,0x40,
0x09,0x21,0xff,0x2e,0x48,0xe8,0xa7,0xff,0xfc,0x07,0x0f,0x0b,0x07,0xdb,0x08,0x27,
0x18,0xff,0xfb,0x01,0x23,0xff,0xfa,0x0d,0x09,0x00,0x0a,0x53,0x75,0x63,0x63,0x65,
0x65,0x64,0x65,0x64,0x00,0xff,0xf9,0x0e,0x42,0x55,0x46,0x46,0x45,0x52,0x45,0x58,
0x41,0x4d,0x50,0x4c,0x45,0x00,0xff,0xf8,0x02,0x03,0xe7,0x03,0xfd,0xfe,0x00,0x0e,
0x04,0x02,0x00,0x05,0x00,0x0a,0x00,0x14,0x00,0x1e,0x00,0x28,0x5b,0xa0,0x01,0x03,
0x68,0x09,0x02,0x00,0x05,0x00,0x04,0x12,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,
0x2d,0x20,0x52,0x73,0x73,0x6c,0x54,0x69,0x6d,0x65,0x0a,0x05,0x0a,0x15,0x10,0x03,
0x09,0x11,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,
0x49,0x6e,0x74,0x03,0x01,0x0d,0x12,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,
0x20,0x52,0x73,0x73,0x6c,0x55,0x49,0x6e,0x74,0x04,0x01,0x11,0x1a,0x45,0x6c,0x65,
0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x52,0x65,0x61,0x6c,0x20,
0x2d,0x20,0x42,0x6c,0x61,0x6e,0x6b,0x08,0x00
  };
  printf( "--- filter\n" );
  m = MDMsg::unpack( filt, 0, sizeof( filt ), RWF_FILTER_LIST_TYPE_ID,
                     dict, mem );
  m->print( &mout );
  mem.reuse();

  static uint8_t sers[] = {
0x04,0x05,0x01,0x00,0x01,0xfe,0x00,0x68,0x09,0x02,0x00,0x05,0x00,0x04,0x12,0x45,
0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x54,0x69,0x6d,
0x65,0x0a,0x05,0x0a,0x15,0x10,0x03,0x09,0x11,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,
0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x49,0x6e,0x74,0x03,0x01,0x0d,0x12,0x45,0x6c,
0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x55,0x49,0x6e,0x74,
0x04,0x01,0x11,0x1a,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,
0x73,0x6c,0x52,0x65,0x61,0x6c,0x20,0x2d,0x20,0x42,0x6c,0x61,0x6e,0x6b,0x08,0x00
  };
  printf( "--- series\n" );
  m = MDMsg::unpack( sers, 0, sizeof( sers ), RWF_SERIES_TYPE_ID, dict, mem );
  m->print( &mout );
  mem.reuse();

  static uint8_t vect[] = {
0x0a,0x05,0x68,0x09,0x02,0x00,0x05,0x00,0x04,0x12,0x45,0x6c,0x65,0x6d,0x65,0x6e,
0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x54,0x69,0x6d,0x65,0x0a,0x05,0x0a,0x15,
0x10,0x03,0x09,0x11,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,
0x73,0x6c,0x49,0x6e,0x74,0x03,0x01,0x0d,0x12,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,
0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x55,0x49,0x6e,0x74,0x04,0x01,0x11,0x1a,0x45,
0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x52,0x65,0x61,
0x6c,0x20,0x2d,0x20,0x42,0x6c,0x61,0x6e,0x6b,0x08,0x00,0x01,0x00,0x01,0x01,0x01,
0x68,0x09,0x02,0x00,0x05,0x00,0x04,0x12,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,
0x2d,0x20,0x52,0x73,0x73,0x6c,0x54,0x69,0x6d,0x65,0x0a,0x05,0x0a,0x15,0x10,0x03,
0x09,0x11,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,
0x49,0x6e,0x74,0x03,0x01,0x0d,0x12,0x45,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x20,0x2d,
0x20,0x52,0x73,0x73,0x6c,0x55,0x49,0x6e,0x74,0x04,0x01,0x11,0x1a,0x45,0x6c,0x65,
0x6d,0x65,0x6e,0x74,0x20,0x2d,0x20,0x52,0x73,0x73,0x6c,0x52,0x65,0x61,0x6c,0x20,
0x2d,0x20,0x42,0x6c,0x61,0x6e,0x6b,0x08,0x00
  };
  printf( "--- vector\n" );
  m = MDMsg::unpack( vect, 0, sizeof( vect ), RWF_VECTOR_TYPE_ID, dict, mem );
  m->print( &mout );
  mem.reuse();

  static uint8_t refr[] = {
0x00,0x18,0x02,0x07,0x00,0x00,0x00,0x06,0x81,0xe8,0x09,0x09,0x00,0x00,0x02,0x00,
0x00,0x22,0x80,0x06,0x03,0x01,0x03,0x54,0x52,0x49,0x0a,0x04,0x04,0x80,0x8c,0x09,
0x03,0x02,0x00,0x05,0x00,0x10,0x00,0x10,0x04,0x1e,0x0b,0x07,0xda,0x04,0x38,0x02,
0x5b,0xa0,0x04,0x39,0x02,0x5b,0xa0,0x00,0x16,0x00,0x00,0x18,0x03,0x0c,0x00,0xe3,
0x00,0x19,0x03,0x0a,0x59,0x11,0x00,0x12,0x03,0x08,0x27,0x18,0xff,0xff,0x03,0x00,
0xff,0x98,0xff,0xfe,0x04,0x40,0x48,0xf5,0xc3,0xff,0xfd,0x08,0x40,0x09,0x21,0xff,
0x2e,0x48,0xe8,0xa7,0xff,0xfc,0x07,0x0f,0x0b,0x07,0xdb,0x08,0x27,0x18,0xff,0xfb,
0x01,0x23,0xff,0xfa,0x0d,0x09,0x00,0x0a,0x53,0x75,0x63,0x63,0x65,0x65,0x64,0x65,
0x64,0x00,0xff,0xf9,0x0e,0x42,0x55,0x46,0x46,0x45,0x52,0x45,0x58,0x41,0x4d,0x50,
0x4c,0x45,0x00,0xff,0xf8,0x02,0x03,0xe7,0x03,0xfd,0xfe,0x00,0x0e,0x04,0x02,0x00,
0x05,0x00,0x0a,0x00,0x14,0x00,0x1e,0x00,0x28,0x5b,0xa0,0x03,0x00,0x03,0x01,0x01,
0x01,0xfe,0x00,0x8c,0x09,0x03,0x02,0x00,0x05,0x00,0x10,0x00,0x10,0x04,0x1e,0x0b,
0x07,0xda,0x04,0x38,0x02,0x5b,0xa0,0x04,0x39,0x02,0x5b,0xa0,0x00,0x16,0x00,0x00,
0x18,0x03,0x0c,0x00,0xe3,0x00,0x19,0x03,0x0a,0x59,0x11,0x00,0x12,0x03,0x08,0x27,
0x18,0xff,0xff,0x03,0x00,0xff,0x98,0xff,0xfe,0x04,0x40,0x48,0xf5,0xc3,0xff,0xfd,
0x08,0x40,0x09,0x21,0xff,0x2e,0x48,0xe8,0xa7,0xff,0xfc,0x07,0x0f,0x0b,0x07,0xdb,
0x08,0x27,0x18,0xff,0xfb,0x01,0x23,0xff,0xfa,0x0d,0x09,0x00,0x0a,0x53,0x75,0x63,
0x63,0x65,0x65,0x64,0x65,0x64,0x00,0xff,0xf9,0x0e,0x42,0x55,0x46,0x46,0x45,0x52,
0x45,0x58,0x41,0x4d,0x50,0x4c,0x45,0x00,0xff,0xf8,0x02,0x03,0xe7,0x03,0xfd,0xfe,
0x00,0x0e,0x04,0x02,0x00,0x05,0x00,0x0a,0x00,0x14,0x00,0x1e,0x00,0x28,0x5b,0xa0,
0x02,0x01,0x02,0x8c,0x09,0x03,0x02,0x00,0x05,0x00,0x10,0x00,0x10,0x04,0x1e,0x0b,
0x07,0xda,0x04,0x38,0x02,0x5b,0xa0,0x04,0x39,0x02,0x5b,0xa0,0x00,0x16,0x00,0x00,
0x18,0x03,0x0c,0x00,0xe3,0x00,0x19,0x03,0x0a,0x59,0x11,0x00,0x12,0x03,0x08,0x27,
0x18,0xff,0xff,0x03,0x00,0xff,0x98,0xff,0xfe,0x04,0x40,0x48,0xf5,0xc3,0xff,0xfd,
0x08,0x40,0x09,0x21,0xff,0x2e,0x48,0xe8,0xa7,0xff,0xfc,0x07,0x0f,0x0b,0x07,0xdb,
0x08,0x27,0x18,0xff,0xfb,0x01,0x23,0xff,0xfa,0x0d,0x09,0x00,0x0a,0x53,0x75,0x63,
0x63,0x65,0x65,0x64,0x65,0x64,0x00,0xff,0xf9,0x0e,0x42,0x55,0x46,0x46,0x45,0x52,
0x45,0x58,0x41,0x4d,0x50,0x4c,0x45,0x00,0xff,0xf8,0x02,0x03,0xe7,0x03,0xfd,0xfe,
0x00,0x0e,0x04,0x02,0x00,0x05,0x00,0x0a,0x00,0x14,0x00,0x1e,0x00,0x28,0x5b,0xa0,
0x03,0x01,0x03
  };
  printf( "--- refresh\n" );
  m = MDMsg::unpack( refr, 0, sizeof( refr ), RWF_MSG_TYPE_ID, dict, mem );
  m->print( &mout );
  mem.reuse();
}
